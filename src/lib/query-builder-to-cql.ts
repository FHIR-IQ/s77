/**
 * Query Builder to CQL Transformer
 * Converts react-querybuilder rules to CQL (Clinical Quality Language) expressions
 */

import type { RuleGroupType, RuleType } from 'react-querybuilder';
import { getFieldDefinition, type FhirDataType } from './fhir-schema-service';

export interface CQLTransformOptions {
  libraryName?: string;
  libraryVersion?: string;
  measurementPeriodParam?: boolean;
  includeComments?: boolean;
  populationName?: string;
  resourceTypes?: string[];
  valueSets?: Array<{ name: string; oid: string }>;
}

export interface CQLTransformResult {
  cql: string;
  expressions: string[];
  retrieveStatements: string[];
  warnings: string[];
}

/**
 * Transform a query builder rule group to CQL
 */
export function queryBuilderToCQL(
  query: RuleGroupType,
  options: CQLTransformOptions = {}
): CQLTransformResult {
  const {
    libraryName = 'GeneratedMeasure',
    libraryVersion = '1.0.0',
    measurementPeriodParam = true,
    includeComments = true,
    populationName = 'Initial Population',
    resourceTypes = [],
    valueSets = [],
  } = options;

  const warnings: string[] = [];
  const retrieveStatements: Set<string> = new Set();
  const expressions: string[] = [];

  // Generate the main expression from the query
  const whereClause = transformRuleGroup(query, resourceTypes, retrieveStatements, warnings);

  // Build the complete CQL library
  const lines: string[] = [];

  // Header comment
  if (includeComments) {
    lines.push('/*');
    lines.push(` * ${libraryName}`);
    lines.push(' * Generated by CQL Visual Builder');
    lines.push(` * Generated on: ${new Date().toISOString()}`);
    lines.push(' */');
    lines.push('');
  }

  // Library declaration
  lines.push(`library ${sanitizeIdentifier(libraryName)} version '${libraryVersion}'`);
  lines.push('');

  // Using FHIR
  lines.push("using FHIR version '4.0.1'");
  lines.push('');

  // Include FHIRHelpers
  lines.push("include FHIRHelpers version '4.0.1' called FHIRHelpers");
  lines.push('');

  // Value sets
  if (valueSets.length > 0) {
    if (includeComments) {
      lines.push('// Value Sets');
    }
    valueSets.forEach((vs) => {
      lines.push(`valueset "${vs.name}": '${vs.oid}'`);
    });
    lines.push('');
  }

  // Measurement Period parameter
  if (measurementPeriodParam) {
    const year = new Date().getFullYear();
    lines.push('parameter "Measurement Period" Interval<DateTime>');
    lines.push(`  default Interval[@${year}-01-01T00:00:00.0, @${year + 1}-01-01T00:00:00.0)`);
    lines.push('');
  }

  // Context
  lines.push('context Patient');
  lines.push('');

  // Retrieve statements as helper definitions
  if (retrieveStatements.size > 0 && includeComments) {
    lines.push('// FHIR Resource Retrieves');
  }
  retrieveStatements.forEach((retrieve) => {
    lines.push(retrieve);
    expressions.push(retrieve);
  });
  if (retrieveStatements.size > 0) {
    lines.push('');
  }

  // Main population definition
  if (includeComments) {
    lines.push('/*');
    lines.push(` * ${populationName}`);
    lines.push(' * Generated from visual query builder');
    lines.push(' */');
  }

  const populationDef = `define "${populationName}":\n  ${whereClause || 'true'}`;
  lines.push(populationDef);
  expressions.push(populationDef);

  return {
    cql: lines.join('\n'),
    expressions,
    retrieveStatements: Array.from(retrieveStatements),
    warnings,
  };
}

/**
 * Transform a rule group (AND/OR grouping) to CQL
 */
function transformRuleGroup(
  group: RuleGroupType,
  resourceTypes: string[],
  retrieveStatements: Set<string>,
  warnings: string[]
): string {
  const { combinator, rules } = group;

  if (!rules || rules.length === 0) {
    return 'true';
  }

  const conditions: string[] = [];

  for (const rule of rules) {
    if ('combinator' in rule) {
      // Nested group
      const nestedCondition = transformRuleGroup(rule as RuleGroupType, resourceTypes, retrieveStatements, warnings);
      if (nestedCondition && nestedCondition !== 'true') {
        conditions.push(`(${nestedCondition})`);
      }
    } else {
      // Single rule
      const condition = transformRule(rule as RuleType, resourceTypes, retrieveStatements, warnings);
      if (condition) {
        conditions.push(condition);
      }
    }
  }

  if (conditions.length === 0) {
    return 'true';
  }

  if (conditions.length === 1) {
    return conditions[0];
  }

  const cqlCombinator = combinator === 'or' ? '\n    or ' : '\n    and ';
  return conditions.join(cqlCombinator);
}

/**
 * Transform a single rule to CQL
 */
function transformRule(
  rule: RuleType,
  resourceTypes: string[],
  retrieveStatements: Set<string>,
  warnings: string[]
): string {
  const { field, operator, value } = rule;

  if (!field) {
    warnings.push('Rule missing field');
    return '';
  }

  // Parse field name (format: ResourceType.fieldName or just fieldName)
  const fieldParts = field.split('.');
  let resourceType: string;
  let fieldName: string;

  if (fieldParts.length >= 2) {
    resourceType = fieldParts[0];
    fieldName = fieldParts.slice(1).join('.');
  } else {
    // Default to Patient if no resource type specified
    resourceType = resourceTypes[0] || 'Patient';
    fieldName = field;
  }

  // Get field definition for type information
  const fieldDef = getFieldDefinition(resourceType, fieldName);
  const dataType: FhirDataType = fieldDef?.dataType || 'string';

  // Generate retrieve statement for non-Patient resources
  if (resourceType !== 'Patient') {
    const retrieveName = `${resourceType}s`;
    const retrieveDef = `define "${retrieveName}":\n  [${resourceType}]`;
    retrieveStatements.add(retrieveDef);
  }

  // Build the CQL expression based on operator and data type
  const expression = buildCQLExpression(resourceType, fieldName, operator, value, dataType, warnings);

  if (resourceType !== 'Patient') {
    const resourceAlias = resourceType.charAt(0).toUpperCase();
    return `exists([${resourceType}] ${resourceAlias} where ${expression})`;
  }

  return expression;
}

/**
 * Build a CQL expression for a specific field, operator, and value
 */
function buildCQLExpression(
  resourceType: string,
  fieldName: string,
  operator: string,
  value: unknown,
  dataType: FhirDataType,
  warnings: string[]
): string {
  // Build the left side of the expression (field accessor)
  const fieldAccessor = buildFieldAccessor(resourceType, fieldName, dataType);

  // Handle null operators
  if (operator === 'is null' || operator === 'null') {
    return `${fieldAccessor} is null`;
  }
  if (operator === 'is not null' || operator === 'notNull') {
    return `${fieldAccessor} is not null`;
  }

  // Handle special operators
  switch (operator) {
    case 'contains':
      return `Contains(${fieldAccessor}, '${escapeString(String(value))}')`;

    case 'startsWith':
      return `StartsWith(${fieldAccessor}, '${escapeString(String(value))}')`;

    case 'endsWith':
      return `EndsWith(${fieldAccessor}, '${escapeString(String(value))}')`;

    case 'in':
      // Value set membership
      return `${fieldAccessor} in "${value}"`;

    case 'during':
      // During measurement period
      return `${fieldAccessor} during "Measurement Period"`;

    case 'between':
      // Between two values
      if (Array.isArray(value) && value.length === 2) {
        const formattedLow = formatValue(value[0], dataType);
        const formattedHigh = formatValue(value[1], dataType);
        return `${fieldAccessor} between ${formattedLow} and ${formattedHigh}`;
      }
      warnings.push(`'between' operator requires two values for field ${fieldName}`);
      return '';

    case 'overlaps':
      return `${fieldAccessor} overlaps "Measurement Period"`;

    case 'includes':
      return `${fieldAccessor} includes "Measurement Period"`;

    case '~':
      // Equivalence for CodeableConcept
      return `${fieldAccessor} ~ ${formatValue(value, dataType)}`;

    default:
      // Standard comparison operators
      const formattedValue = formatValue(value, dataType);
      return `${fieldAccessor} ${operator} ${formattedValue}`;
  }
}

/**
 * Build the field accessor path in CQL
 */
function buildFieldAccessor(resourceType: string, fieldName: string, dataType: FhirDataType): string {
  if (resourceType === 'Patient') {
    // For Patient context, access directly
    if (fieldName === 'gender' || fieldName === 'birthDate' || fieldName === 'id' || fieldName === 'active') {
      return `Patient.${fieldName}`;
    }
    if (fieldName === 'deceasedBoolean') {
      return 'Patient.deceased as boolean';
    }
    if (fieldName === 'deceasedDateTime') {
      return 'Patient.deceased as dateTime';
    }
    return `Patient.${fieldName}`;
  }

  // For other resources, use exists with where clause pattern
  const resourceAlias = resourceType.charAt(0).toUpperCase();

  // Handle nested fields
  const pathParts = fieldName.split('.');
  let accessor = resourceAlias;

  for (const part of pathParts) {
    accessor += `.${part}`;
  }

  // Add value accessors for certain data types
  if (dataType === 'CodeableConcept') {
    // For CodeableConcept, we might need to access the coding
    return accessor;
  }
  if (dataType === 'code' && !fieldName.includes('status')) {
    // For coded values that aren't status fields
    return `${accessor}.coding[0].code`;
  }

  return accessor;
}

/**
 * Format a value for CQL based on its data type
 */
function formatValue(value: unknown, dataType: FhirDataType): string {
  if (value === null || value === undefined) {
    return 'null';
  }

  switch (dataType) {
    case 'string':
      return `'${escapeString(String(value))}'`;

    case 'code':
      return `'${escapeString(String(value))}'`;

    case 'boolean':
      return value === true || value === 'true' ? 'true' : 'false';

    case 'date':
      return `@${formatDateString(String(value))}`;

    case 'dateTime':
      return `@${formatDateTimeString(String(value))}`;

    case 'integer':
      return String(parseInt(String(value), 10));

    case 'decimal':
      return String(parseFloat(String(value)));

    case 'CodeableConcept':
    case 'Coding':
      // If it looks like an OID, reference value set
      if (String(value).includes('.')) {
        return `"${value}"`;
      }
      // Otherwise treat as a code
      return `Code '${escapeString(String(value))}'`;

    case 'Quantity':
      // Try to parse as quantity with unit
      const qtyMatch = String(value).match(/^([\d.]+)\s*(.+)?$/);
      if (qtyMatch) {
        const [, num, unit] = qtyMatch;
        return unit ? `${num} '${unit}'` : num;
      }
      return String(value);

    case 'Age':
      return `${value} years`;

    default:
      return `'${escapeString(String(value))}'`;
  }
}

/**
 * Escape a string for CQL
 */
function escapeString(str: string): string {
  return str
    .replace(/\\/g, '\\\\')
    .replace(/'/g, "\\'");
}

/**
 * Format a date string for CQL (@YYYY-MM-DD format)
 */
function formatDateString(dateStr: string): string {
  try {
    const date = new Date(dateStr);
    const year = date.getUTCFullYear();
    const month = String(date.getUTCMonth() + 1).padStart(2, '0');
    const day = String(date.getUTCDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  } catch {
    return dateStr;
  }
}

/**
 * Format a datetime string for CQL
 */
function formatDateTimeString(dateStr: string): string {
  try {
    const date = new Date(dateStr);
    const year = date.getUTCFullYear();
    const month = String(date.getUTCMonth() + 1).padStart(2, '0');
    const day = String(date.getUTCDate()).padStart(2, '0');
    const hours = String(date.getUTCHours()).padStart(2, '0');
    const minutes = String(date.getUTCMinutes()).padStart(2, '0');
    const seconds = String(date.getUTCSeconds()).padStart(2, '0');
    return `${year}-${month}-${day}T${hours}:${minutes}:${seconds}.0`;
  } catch {
    return dateStr;
  }
}

/**
 * Sanitize an identifier for CQL (remove special chars, ensure valid)
 */
function sanitizeIdentifier(name: string): string {
  return name
    .replace(/[^a-zA-Z0-9_]/g, '')
    .replace(/^[0-9]/, '_$&');
}

/**
 * Generate a complete CQL measure from query builder rules
 */
export function generateCompleteMeasure(
  initialPopulation: RuleGroupType,
  denominator?: RuleGroupType,
  numerator?: RuleGroupType,
  options: CQLTransformOptions = {}
): string {
  const {
    libraryName = 'GeneratedMeasure',
    libraryVersion = '1.0.0',
    valueSets = [],
  } = options;

  const allRetrieveStatements: Set<string> = new Set();
  const warnings: string[] = [];

  // Transform each population
  const ipWhere = transformRuleGroup(initialPopulation, options.resourceTypes || [], allRetrieveStatements, warnings);
  const denomWhere = denominator
    ? transformRuleGroup(denominator, options.resourceTypes || [], allRetrieveStatements, warnings)
    : '"Initial Population"';
  const numerWhere = numerator
    ? transformRuleGroup(numerator, options.resourceTypes || [], allRetrieveStatements, warnings)
    : 'true';

  const year = new Date().getFullYear();

  const lines: string[] = [
    '/*',
    ` * ${libraryName}`,
    ' * Clinical Quality Measure',
    ' * Generated by CQL Visual Builder',
    ` * Generated on: ${new Date().toISOString()}`,
    ' */',
    '',
    `library ${sanitizeIdentifier(libraryName)} version '${libraryVersion}'`,
    '',
    "using FHIR version '4.0.1'",
    '',
    "include FHIRHelpers version '4.0.1' called FHIRHelpers",
    "include SupplementalDataElements version '3.0.0' called SDE",
    '',
  ];

  // Value sets
  if (valueSets.length > 0) {
    lines.push('// Value Sets');
    valueSets.forEach((vs) => {
      lines.push(`valueset "${vs.name}": '${vs.oid}'`);
    });
    lines.push('');
  }

  lines.push(
    'parameter "Measurement Period" Interval<DateTime>',
    `  default Interval[@${year}-01-01T00:00:00.0, @${year + 1}-01-01T00:00:00.0)`,
    '',
    'context Patient',
    '',
  );

  // SDE definitions
  lines.push(
    '// Supplemental Data Elements',
    'define "SDE Ethnicity": SDE."SDE Ethnicity"',
    'define "SDE Payer": SDE."SDE Payer"',
    'define "SDE Race": SDE."SDE Race"',
    'define "SDE Sex": SDE."SDE Sex"',
    '',
  );

  // Retrieve statements
  if (allRetrieveStatements.size > 0) {
    lines.push('// Resource Retrieves');
    allRetrieveStatements.forEach((retrieve) => {
      lines.push(retrieve);
    });
    lines.push('');
  }

  // Population definitions
  lines.push(
    '/*',
    ' * Initial Population',
    ' */',
    'define "Initial Population":',
    `  ${ipWhere}`,
    '',
    '/*',
    ' * Denominator',
    ' */',
    'define "Denominator":',
    `  ${denomWhere}`,
    '',
    '/*',
    ' * Denominator Exclusions',
    ' */',
    'define "Denominator Exclusions":',
    '  false',
    '',
    '/*',
    ' * Numerator',
    ' */',
    'define "Numerator":',
    `  ${numerWhere}`,
    '',
    '/*',
    ' * Numerator Exclusions',
    ' */',
    'define "Numerator Exclusions":',
    '  false',
  );

  return lines.join('\n');
}

/**
 * Generate a snippet for a single expression
 */
export function generateExpressionSnippet(
  query: RuleGroupType,
  expressionName: string,
  resourceTypes: string[] = []
): string {
  const retrieveStatements: Set<string> = new Set();
  const warnings: string[] = [];

  const whereClause = transformRuleGroup(query, resourceTypes, retrieveStatements, warnings);

  const lines: string[] = [];

  // Add retrieve statements
  retrieveStatements.forEach((retrieve) => {
    lines.push(retrieve);
  });

  if (lines.length > 0) {
    lines.push('');
  }

  // Add the expression
  lines.push(`define "${expressionName}":`);
  lines.push(`  ${whereClause}`);

  return lines.join('\n');
}
